library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity portao is
  generic (
    -- tempo máximo no estado ABERTO (em ciclos de clock)
    -- exemplo: em clock de 50 MHz, 50_000_000 ≈ 1 segundo
    OPEN_TIME_MAX : natural := 50_000_000
  );
  port (
    clk         : in  std_logic;
    rst_n       : in  std_logic;   -- reset assíncrono, ativo em 0

    btn_cmd     : in  std_logic;   -- botão/comando remoto
    limit_open  : in  std_logic;   -- fim de curso portão totalmente aberto
    limit_close : in  std_logic;   -- fim de curso portão totalmente fechado
    sensor_obs  : in  std_logic;   -- sensor de obstáculo
    emergency   : in  std_logic;   -- emergência

    motor_open  : out std_logic;   -- liga motor no sentido abrir
    motor_close : out std_logic;   -- liga motor no sentido fechar

    state_debug : out std_logic_vector(2 downto 0)  -- LEDs de debug/estado
  );
end entity portao;

architecture rtl of portao is

  ---------------------------------------------------------------------------
  -- Definição de estados
  ---------------------------------------------------------------------------
  type state_type is (
    S_FECHADO,
    S_ABRINDO,
    S_ABERTO,
    S_FECHANDO,
    S_PAUSADO,
    S_EMERGENCIA
  );

  signal state_reg, state_next : state_type;

  ---------------------------------------------------------------------------
  -- Sinais para temporizador do estado ABERTO
  ---------------------------------------------------------------------------
  signal open_counter    : unsigned(31 downto 0) := (others => '0');
  signal open_counter_en : std_logic := '0';
  signal open_timeout    : std_logic;

  ---------------------------------------------------------------------------
  -- Sincronização e detecção de borda do botão
  ---------------------------------------------------------------------------
  signal btn_sync_0, btn_sync_1 : std_logic := '0';
  signal btn_rise               : std_logic;

begin

  ---------------------------------------------------------------------------
  -- Sincronização do botão (2 flip-flops)
  ---------------------------------------------------------------------------
  process(clk, rst_n)
  begin
    if rst_n = '0' then
      btn_sync_0 <= '0';
      btn_sync_1 <= '0';
    elsif rising_edge(clk) then
      btn_sync_0 <= btn_cmd;
      btn_sync_1 <= btn_sync_0;
    end if;
  end process;

  -- detecção de borda de subida do botão
  btn_rise <= '1' when (btn_sync_0 = '1' and btn_sync_1 = '0') else '0';

  ---------------------------------------------------------------------------
  -- Registrador de estado (FSM)
  ---------------------------------------------------------------------------
  process(clk, rst_n)
  begin
    if rst_n = '0' then
      state_reg <= S_FECHADO;
    elsif rising_edge(clk) then
      state_reg <= state_next;
    end if;
  end process;

  ---------------------------------------------------------------------------
  -- Contador de tempo no estado ABERTO
  ---------------------------------------------------------------------------
  process(clk, rst_n)
  begin
    if rst_n = '0' then
      open_counter <= (others => '0');
    elsif rising_edge(clk) then
      if open_counter_en = '1' then
        if open_counter = to_unsigned(OPEN_TIME_MAX - 1, open_counter'length) then
          open_counter <= open_counter;  -- trava no máximo
        else
          open_counter <= open_counter + 1;
        end if;
      else
        open_counter <= (others => '0');
      end if;
    end if;
  end process;

  open_timeout <= '1' when open_counter = to_unsigned(OPEN_TIME_MAX - 1, open_counter'length)
                  else '0';

  ---------------------------------------------------------------------------
  -- Lógica de próximo estado (FSM)
  ---------------------------------------------------------------------------
  process(state_reg, btn_rise, limit_open, limit_close, sensor_obs, emergency, open_timeout)
  begin
    -- valores padrão
    state_next      <= state_reg;
    open_counter_en <= '0';

    if emergency = '1' then
      -- emergência domina qualquer estado
      state_next <= S_EMERGENCIA;

    else
      case state_reg is

        when S_FECHADO =>
          if btn_rise = '1' then
            state_next <= S_ABRINDO;
          end if;

        when S_ABRINDO =>
          if limit_open = '1' then
            state_next <= S_ABERTO;
          elsif btn_rise = '1' then
            state_next <= S_PAUSADO;
          end if;

        when S_ABERTO =>
          open_counter_en <= '1';
          if open_timeout = '1' or btn_rise = '1' then
            state_next <= S_FECHANDO;
          end if;

        when S_FECHANDO =>
          if limit_close = '1' then
            state_next <= S_FECHADO;
          elsif sensor_obs = '1' then
            -- encontrou obstáculo enquanto fecha → reabrir
            state_next <= S_ABRINDO;
          elsif btn_rise = '1' then
            state_next <= S_PAUSADO;
          end if;

        when S_PAUSADO =>
          -- aqui deixei simples: novo comando volta fechando
          -- se quiser, pode guardar direção anterior em outro sinal
          if btn_rise = '1' then
            state_next <= S_FECHANDO;
          end if;

        when S_EMERGENCIA =>
          -- só sai desse estado com reset
          state_next <= S_EMERGENCIA;

      end case;
    end if;
  end process;

  ---------------------------------------------------------------------------
  -- Lógica de saída (Moore): motor + debug
  ---------------------------------------------------------------------------
  process(state_reg)
  begin
    motor_open  <= '0';
    motor_close <= '0';
    state_debug <= "000";

    case state_reg is

      when S_FECHADO =>
        state_debug <= "000";

      when S_ABRINDO =>
        motor_open  <= '1';
        state_debug <= "001";

      when S_ABERTO =>
        state_debug <= "010";

      when S_FECHANDO =>
        motor_close <= '1';
        state_debug <= "011";

      when S_PAUSADO =>
        state_debug <= "100";

      when S_EMERGENCIA =>
        state_debug <= "101";

    end case;
  end process;

end architecture rtl;
